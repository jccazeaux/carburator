{"name":"Diapason","tagline":"Asynchronous dependency injection that works with any Promise framework","body":"![Travis CI](https://travis-ci.org/jccazeaux/diapason.svg?branch=master)\r\n\r\n# Diapason\r\nTiny, configurable dependency injection framework. Diapason uses `promises` to handle asynchronous dependency injections.\r\n\r\n# Installation\r\n\r\n* Download the [latest release](https://github.com/jccazeaux/diapason/releases/download/v0.2.1/diapason.min.js).\r\n* Clone the repo: `git clone https://github.com/jccazeaux/diapason.git`.\r\n* Install with npm: `npm install diapason`.\r\n\r\n# How it works\r\nDiapason acts as an object container. You can add objets to containers. Then execute function with dependency injection.\r\n\r\n## Create a container\r\nDiapason comes with no container, you must create one or more\r\n\r\n```Javascript\r\ndiapason.config\r\n\t.container(\"myContainer\")\r\n\t.container(\"myOtherContainer\");\r\n```\r\n\r\nThis will create the containers and the functions to add content.\r\n\r\n## Declare objects to a container\r\nWhen creating a container, a function will be created to specifically add objets to that container. The name of the function will be the name of the container\r\n\r\n```Javascript\r\ndiapason.myContainer(\"myObject\", \"Hello\")\r\ndiapason.myOtherContainer(\"myOtherObject\", \"World !\")\r\n```\r\n\r\n## Dependency injection\r\n\r\n```Javascript\r\ndiapason.inject([\"myObject\", \"myOtherObject\", function(myObject, myOtherObject) {\r\n\tconsole.log(myObject + \", \" + myOtherObject);\r\n}]);\r\n// > Hello, World !\r\n```\r\n\r\n# Asynchronous mecanism\r\n## What does that mean\r\nIt means any injection may be a promise. Diapason will wait recursively all dependencies to be be resolved before calling the injection functions.\r\n\r\n```Javascript\r\n// Create an async dependency\r\ndiapason.myContainer(\"a\", Promise.resolve(\"Hello World\"));\r\n// Create an other async dependency that needs a\r\ndiapason.myContainer(\"b\", [\"a\", function(a) {\r\n\t// When injected, will wait for a to be ready\r\n\treturn Promise.resolve(a + \" !\");\r\n}]);\r\n// Inject dependency\r\ndiapason.inject([\"a\", function(a) {\r\n\t// Enters here only when injections are ready\r\n\tconsole.log(a); // Hello World !\r\n}]);\r\n```\r\n\r\n## Promises API\r\nDiapason supports 3 Promises frameworks\r\n* Ecmascript 2016 (default)\r\n* [Q](http://documentup.com/kriskowal/q/)\r\n* [Bluebird](http://bluebirdjs.com/)\r\n\r\n**Diapason does not include any Promise framework, you must add the one you want (or use ES2016 if your browser supports it)**\r\n\r\n## Switch promise framework\r\nTo switch `Promise` framework in diapason \r\n```Javascript\r\ndiapason.config.usePromise(\"ES\");\r\ndiapason.config.usePromise(\"Q\");\r\ndiapason.config.usePromise(\"bluebird\");\r\n```\r\n\r\n## Configure an other promise framework\r\nDiapason can be adapted to work on any other `Promise` framework. To add a new one use `config.promiseAdapter` function. This function must return an object to define 4 elements\r\n* `resolve(value)`: function to create a `Promise` that is resolved with given value\r\n* `reject(value)`: function to create a `Promise` that is rejected with given value\r\n* `all(iterable)`: function that will wait for more than one promise\r\n* `thenAlias`: Alias for `then` function\r\n\r\nAs examples, `Q` and `bluebird` adapters are defined like this in diapason\r\n```Javascript\r\ndiapason.config.promiseAdapter(\"Q\", function() {\r\n\treturn {\r\n\t\tresolve: Q,\r\n\t\treject: function(value) {\r\n\t\t\treturn Q().then(function() {\r\n\t\t\t\tthrow value;\r\n\t\t\t});\r\n\t\t},\r\n\t\tall: function(value) {\r\n\t\t\treturn Q.all(value)\r\n\t\t},\r\n\t\tthenAlias: \"then\"\r\n\t};\r\n});\r\ndiapason.config.promiseAdapter(\"bluebird\", function() {\r\n\treturn {\r\n\t\tresolve: function(value) {\r\n\t\t\treturn Promise.resolve(value)\r\n\t\t},\r\n\t\treject: function(value) {\r\n\t\t\treturn Promise.reject(value)\r\n\t\t},\r\n\t\tall: function(value) {\r\n\t\t\treturn Promise.all(value)\r\n\t\t},\r\n\t\tthenAlias: \"then\"\r\n\t};\r\n});\r\n```\r\n\r\n\r\n# Other capabilities\r\n## Declaring an object as singleton or prototype\r\nBy default, objects will be treated as singleton. You can declare them as protorypes using this method. This concerns only function() to determine if they will be reexecuted.\r\n\r\n```Javascript\r\n// Declare as singleton (by default)\r\ndiapason.myContainer(\"myObject\", function() {\r\n\treturn {\r\n\t\tmessage: \"Hello, World !\";\r\n\t};\r\n}).asSingleton();\r\n// Declare as prototype\r\ndiapason.myContainer(\"myObject\", function() {\r\n\treturn {\r\n\t\tmessage: \"Hello, World !\";\r\n\t};\r\n}).asPrototype();\r\n```\r\n\r\n## Injecting from specific container\r\nYou can choose the container wich will contain your object in the name of the injection\r\n\r\n```javascript\r\n// diapason will search only in myContainer for myObject.\r\ndiapason.inject([\"myContainer:myObject\"], function(myObject) {\r\n\tconsole.log(myObject);\r\n});\r\n```\r\n\r\n## Declaring executor\r\nThis is usefull if you want to specify specific handling for objects in the containers when injecting them. Again this is for functions.\r\n\r\nThe default executor executes the functions.\r\n\r\nExemple: get the functions without executing them\r\n```Javascript\r\ndiapason.config\r\n\t.container(\"functions\")\r\n\t.executor(\"functions\", function(obj) {\r\n\t\treturn obj;\r\n\t});\r\n\r\ndiapason.function(\"myFunction\", function() {\r\n\tconsole.log(\"Hello, World !\");\r\n});\r\ndiapason.inject([\"myFunction\", function(myFunction) {\r\n\tmyFunction();\r\n}]);\r\n```\r\n\r\n## Resetting\r\nYou can reset a container, wich means the container will no longer be available.\r\n\r\n```Javascript\r\n// Reset a container\r\ndiapason.reset(\"myContainer\");\r\n// Reset all\r\ndiapason.reset();\r\n```\r\n\r\n## Clear\r\nYou can clear a container, wich means all objects in it will be deleted. The container will still be available.\r\n\r\n```Javascript\r\n// Clear a container\r\ndiapason.clear(\"myContainer\");\r\n// Clear all containers\r\ndiapason.clear();\r\n```\r\n\r\n## Define execution context (this)\r\nThe injection function will be executed by default on null. You can specify a specific context with the second argument of the inject function\r\n\r\n```javascript\r\ndiapason.inject([\"myObject\"], function(myObject) {\r\n\tconsole.log(myObject);\r\n}, window);\r\n```\r\n\r\n## Contextual dependencies\r\nFor some injections, you may want to add contextual dependencies. This dependencies cannot be added to a container because they must be available only for this execution. These contextual dependencies can be passed as third argument of inject function\r\n\r\n```javascript\r\ndiapason.inject([\"myObject\", \"$scope\"], function(myObject, $scope) {\r\n\tconsole.log(myObject);\r\n}, window, {$scope: {id: 0}});\r\n```\r\n\r\n## Ignore containers\r\nYou can tell diapason to ignore containers on an injection with fourth parameter. This parameter is an array of ignored container names.\r\n\r\n```javascript\r\ndiapason.inject([\"myObject\"], function(myObject) {\r\n\tconsole.log(myObject);\r\n}, window, null, [\"myContainer\"]);\r\n```\r\n\r\n## Automatic dependencies\r\nYou can add automatic dependencies. An automatic dependency is a dependency defined in no container. It's defined\r\n * on a container\r\n * with a name\r\n * as a function\r\n\r\nWhen a dependency of the container is injected, it will have all automatic dependencies configured for this container. The function will be executed with the dependency name in paramater.\r\n\r\nHere is an exemple of usage. We want to have configurable services. The configuration of the service must be stored in a specific container and injected as $configuration for the service.\r\n\r\n```javascript\r\n\tdiapason.config\r\n\t\t.container(\"configuration\")\r\n\t\t.container(\"service\");\r\n\t// For the service container, we add a $configuration automatic dependency\r\n\t// This $configuration dependency will be the &lt;serviceName&gt; dependency in the configuration container\r\n\tdiapason.config.automaticDependencies(\"service\", {\"$configuration\": function(name) {\r\n\t\t// We get the service configuration in the configuration container (ignore service container)\r\n\t\treturn diapason.inject([name, function(config) {\r\n\t\t\treturn config;\r\n\t\t}], null, null, [\"service\"]);\r\n\t}});\r\n\t// We define the configuration\r\n\tdiapason.configuration(\"myService\", \"myService configuration is here\");\r\n\t// Then the service will receive the configuration as $configuration\r\n\tdiapason.service(\"myService\", [\"$configuration\", function($configuration) {\r\n\t\tconsole.log($configuration); // \"myService configuration is here\"\r\n\t}]);\r\n\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}